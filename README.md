# TableFramework
## Excel->二进制 表格生成和读写方案（可以在Unity中使用，lua也可以使用）
  在 Unity 游戏项目中，随着版本的推移，发现用到的数值表越来越多，由于项目之初没有做好加载数值表的管理（均在游戏开始就把数值表全部加载），导致内存越来越大。
  在不改变原来的旧得加载流程的情况下，想到的一个思路：支持数值表按需动态加载某一条数据（某一行），假如原来数值表有1000条目，正常操作一般都是整表IO然后整表反序列，相当于这1000条条目无论是否访问到都会被加载进内存。
  
  首先想到的一个思路是Sqlcipher（sqlite开源库，支持加密）
  
  优点：
  
    1. 支持动态查询。如："select * from 'XTableActivity' Where "Id" = 10001"
    
    2. 业务上可以达到减少内存目的。
    
  缺点（需要解决的问题）：
  
    1. 引入第三方库（深渊巨坑）。虽然Sqlcipher官方提供了源码和编译方案，但是真正编译多平台库实在太过硬核，需要解决来自各平台奇奇怪怪的问题，尤其Sqlcipher还依赖另一个第三方库OPENSSL用于加密。
    
    2. Lua兼容性问题。lua对原版sqlite有比较好的支持，但是对于Sqlcipher，需要编写部分c源码，增加加密接口绑定。除了增加代码支持，还有一个更加操蛋的问题，如果把sql数据的加载全部写在C#中，在lua对数据的访问就会很不方便，一方面，lua call C#存在一个效率问题，不能频繁查询，另一方面数据缓存，在经过lua call C#过程中也产生了大量的缓存占用。所以只能把sql的加载解释部分写到lua里面，这个又回到了第一个问题，首先要升级xlua，然后需要把Sqlcipher源码，luaSqlite源码编译到xlua里面，多平台编译！
    
    3. 加密。因为Sqlite是比较大众的存储方案，市面上随意一个数据库软件都可以轻松打开Sqlite，所以他的文件毫无秘密可言，又由于Sqlite只提供路径加载接口，所以无法使用自定义的加密方案。所以使用Sqlcipher的加密方案。当解决上面的所有问题后，发现，加密后的数据加载速度比没加密慢了十几倍。
    
    4. 需要存在可读写目录。也就是说不能随包打包。
    
    5. 出现问题难以定位问题。毕竟Unity调试库是一件非常麻烦的事。
    
  除了上述的问题外，还有其他零零碎碎的问题。关于Sql方案大家对那个环节（建立Sql，查询，多平台编译库，lua源码）有兴趣可以跟我交流。
  
  么得办法，最后决定自己模仿Sql造轮子。
  ## 目前该方案的设计：
  ### 存储顺序：【描述内存块】【索引内存块】【行索引内存块】【内容内存块】
  
    【描述内存块】=【描述块长度(int32 不可变长)】【列数(int)】【列1类型(int) 名字(string)】 【列2类型(int) 名字(string)】... 【索引(string) 长度(int)】【行索引块长度(int)】【总行数(int)】【内容块长度(int64)】
    【索引内存块】=【主键(具体类型看索引 如:1001)】 【主键(1002)】 【主键(1003)】...... 
    【行索引内存块】=【start end】【start end】【start end】...... 
    【内容内存块】=【行1.......】【行2.......】【行3.....】....
 ### 数据类型
    1. 数值类型 int float bool 使用变长参数正整数保存，牺牲最高位，1代表下一个字节也是属于当前正整数。
    如：128 = 1000000 00000001 00000000  00000000
               0       128
    需要注意的问题负数，负数的保存使用了补码，也就是一个很大的Int32数，正整数。
    Int32补码：uint temp = value < 0 ? (uint)(~Math.Abs(value) + 1) : (uint)value;
    在Int32中会将第一位作为符号位
    
    如 -1 = 1111 1111 1111 1111 1111 1111 1111 1111 在C#中读取四字节存放到int32中，取值是正确的-1.当时在lua中，number是8字节的long类型，这时候lua取出来的值就是错误的 4,294,967,295。

    2. float 暂时 *10000，存在误差值，float不应该存在数值表当中，应该以千分比或者万分比表示，由业务去解释。
    3. fix使用字符串保存。为了不改变定点数。
    4. 字符串string 使用utf8保存
      英文 1字节 0 - 127   
      中文 3字节 128以上   

  
